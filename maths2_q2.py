# -*- coding: utf-8 -*-
"""maths2_q2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z5QQf1nLdSCoFtmzJLxJZGOAG_D-f6wj
"""

import numpy as np
import pandas as pd
from scipy.spatial import distance
from scipy.linalg import cholesky
import csv
import math
import numpy as np

def read_csv_file(filename):
    data = []
    with open(filename, 'r') as file:
        reader = csv.reader(file)
        for row in reader:
            data.append(row)
    return data

# Example usage: Read CSV file
filename = r"/content/train.csv"  # Replace with your CSV file path
file_data = read_csv_file(filename)


float_sample_data = [[float(value) if value.replace('.', '', 1).isdigit() else value for value in row] for row in file_data]

# Print the converted data
print("Converted sample data:")
for row in float_sample_data:
    print(row)

def find_max_euclidean_distance(data):
    max_distance = 0
    xa, xb = 0, 0

    # Skip the first row (header)
    data = data[1:]

    for i in range(len(data)):
        for j in range(i+1, len(data)):
            # Convert the data to float
            #xa = np.array(data[i], dtype=float)
            # xb = np.array(data[j], dtype=float)

            # Calculate Euclidean distance
            #dist = np.linalg.norm(xa - xb)
            dist = math.sqrt(((data[i][0] - data[j][0]) ** 2) + ((data[i][1] - data[j][1]) ** 2))

            if dist > max_distance:
                max_distance = dist
                xa, xb = i, j

    return xa, xb


def classify_data_points(data,xa,xb):
    data = data[1:]
    xa_index = np.array([float(val) for val in data[xa][:-1] if val != ''], dtype=float)  # Convert data points to floats
    xb_index = np.array([float(val) for val in data[xb][:-1] if val != ''], dtype=float)  # Convert data points to floats


    La = []
    Lb = []
    for i in range(len(data)):
        if i != xa and i != xb:  # Skip the xa and xb points
            point = np.array([float(val) for val in data[i][:-1] if val != ''], dtype=float)  # Convert data point to float
            dist_to_xa = distance.euclidean(point, xa_index)
            dist_to_xb = distance.euclidean(point, xb_index)
            if dist_to_xa < dist_to_xb:
                La.append(data[i])
            else:
                Lb.append(data[i])

    return La, Lb


def compute_empirical_mean_covariance(data):
    data = np.array(data)
    mean = np.mean(data, axis=0)
    covariance = np.cov(data, rowvar=False)
    return mean, covariance

def is_positive_definite(matrix):
    try:
        cholesky(matrix)
        return True
    except np.linalg.LinAlgError:
        return False


def mahalanobis_distances(data, mean, covariance):
    distances = []
    for point in data:
        diff = np.array(point) - mean
        mahalanobis_dist = np.sqrt(np.dot(np.dot(diff.T, np.linalg.inv(covariance)), diff))
        distances.append(mahalanobis_dist)
    return distances

xa, xb = find_max_euclidean_distance(float_sample_data)
print("Row numbers of xa and xb:", xa, xb)

La, Lb = classify_data_points(float_sample_data, xa, xb)
print("La:", La)
print("Lb:", Lb)

mean_a, covariance_a = compute_empirical_mean_covariance(La)
print("Mean for La:", mean_a)
print("Covariance for La:", covariance_a)

# Example usage for Lb:
mean_b, covariance_b = compute_empirical_mean_covariance(Lb)
print("Mean for Lb:", mean_b)
print("Covariance for Lb:", covariance_b)
# --------------------------------------------

print("Is covariance_a positive definite?", is_positive_definite(covariance_a))
print("Is covariance_a positive definite?", is_positive_definite(covariance_b))

mahalanobis_distances_a = mahalanobis_distances(La, mean_a, covariance_a)
print("Mahalanobis distances for La:", mahalanobis_distances_a)

# You can similarly compute for Lb
mahalanobis_distances_b = mahalanobis_distances(Lb, mean_b, covariance_b)
print("Mahalanobis distances for Lb:", mahalanobis_distances_b)

new_data_point = [76, 32, 4.39, 1.78, 4.860753, 4.860753, 4.860753, 7.35]
mahalanobis_dist_xa = min(mahalanobis_distances(np.array([new_data_point]), mean_a, covariance_a))
mahalanobis_dist_xb = min(mahalanobis_distances(np.array([new_data_point]), mean_b, covariance_b))

if mahalanobis_dist_xa < mahalanobis_dist_xb:
    print("Label for new data point:", "xa")
else:
    print("Label for new data point:", "xb")

min_distance_a = min(mahalanobis_distances(np.array([new_data_point]), mean_a, covariance_a))
min_distance_b = min(mahalanobis_distances(np.array([new_data_point]), mean_b, covariance_b))

label = "Label A" if min_distance_a < min_distance_b else "Label B"
print("Label for the new point:", label)





# -*- coding: utf-8 -*-
"""
Created on Thu Apr  4 20:02:17 2024

@author: Sneha
"""

# import numpy as np
# from sklearn.linear_model import LinearRegression

# # Assuming your data is loaded into a numpy array named 'data'
# # where each row represents a data point and the last column is the dependent variable
# # and the rest are independent variables

# # Step 1: Data Preparation
# independent_vars = data[:, :-1]  # All columns except the last one
# dependent_var = data[:, -1]      # Last column

# # Step 2: Model Training
# model = LinearRegression()
# model.fit(independent_vars, dependent_var)

# # Step 3: Prediction
# new_data_point = np.array([63, 27, 6.21, 1.79, 4.860753, 4.860753, 4.860753, 4.860753]).reshape(1, -1)
# predicted_label = model.predict(new_data_point)

# print("Predicted label for the new data point:", predicted_label)


# ----------------------------------------------------


# -----------------------------------------------------------------------------------

import numpy as np
import pandas as pd
from scipy.spatial import distance
from scipy.linalg import cholesky
import csv
import numpy as np
from scipy.spatial import distance


data = pd.read_csv(r"/content/Diabetes.csv")
data1 = data.head(1600)
data1 = data1.drop('Diagnosis', axis=1)

print(data1)

data1.to_csv("train.csv")



def read_csv_file(filename):
    data = []
    with open(filename, 'r') as file:
        reader = csv.reader(file)
        for row in reader:
            data.append(row)
    return data

# Example usage: Read CSV file
filename = r"/content/train.csv"  # Replace with your CSV file path
file_data = read_csv_file(filename)
float_sample_data = [[float(value) if value.replace('.', '', 1).isdigit() else value for value in row] for row in file_data]

# Print the converted data
print("Converted sample data:")
for row in float_sample_data:
    print(row)

import math
def find_max_euclidean_distance(data):
    max_distance = 0
    xa, xb = 0, 0

    # Skip the first row (header)
    data = data[1:]

    for i in range(len(data)):
        for j in range(i+1, len(data)):
            # Convert the data to float
            #xa = np.array(data[i], dtype=float)
            # xb = np.array(data[j], dtype=float)

            # Calculate Euclidean distance
            #dist = np.linalg.norm(xa - xb)
            dist = math.sqrt(((data[i][0] - data[j][0]) ** 2) + ((data[i][1] - data[j][1]) ** 2))

            if dist > max_distance:
                max_distance = dist
                xa, xb = i, j

    return xa, xb

def classify_data_points(data,xa,xb):
    data = data[1:]
    xa_index = np.array([float(val) for val in data[xa][:-1] if val != ''], dtype=float)  # Convert data points to floats
    xb_index = np.array([float(val) for val in data[xb][:-1] if val != ''], dtype=float)  # Convert data points to floats


    La = []
    Lb = []
    for i in range(len(data)):
        if i != xa and i != xb:  # Skip the xa and xb points
            point = np.array([float(val) for val in data[i][:-1] if val != ''], dtype=float)  # Convert data point to float
            dist_to_xa = distance.euclidean(point, xa_index)
            dist_to_xb = distance.euclidean(point, xb_index)
            if dist_to_xa < dist_to_xb:
                La.append(data[i])
            else:
                Lb.append(data[i])

    return La, Lb

def compute_empirical_mean_covariance(data):
    data = np.array(data)
    mean = np.mean(data, axis=0)
    covariance = np.cov(data, rowvar=False)
    return mean, covariance

def is_positive_definite(matrix):
    try:
        cholesky(matrix)
        return True
    except np.linalg.LinAlgError:
        return False

def mahalanobis_distances(data, mean, covariance):
    distances = []
    for point in data:
        diff = np.array(point) - mean
        mahalanobis_dist = np.sqrt(np.dot(np.dot(diff.T, np.linalg.inv(covariance)), diff))
        distances.append(mahalanobis_dist)
    return distances

# i)A.
xa, xb = find_max_euclidean_distance(float_sample_data)
print("Row numbers of xa and xb:", xa, xb)
# ------------------------------------------

# i)B.
La, Lb = classify_data_points(float_sample_data, xa, xb)
print("La:", La)
print("Lb:", Lb)

# ----------------------------------------------

# Step 4: Compute empirical mean and covariance matrices
# i)C.

mean_a, covariance_a = compute_empirical_mean_covariance(La)
print("Mean for La:", mean_a)
print("Covariance for La:", covariance_a)

mean_b, covariance_b = compute_empirical_mean_covariance(Lb)
print("Mean for Lb:", mean_b)
print("Covariance for Lb:", covariance_b)
# --------------------------------------------------

# Step 5: Verify if covariance matrices are positive definite
# i)D.
print("Is covariance_a positive definite?", is_positive_definite(covariance_a))

# ----------------------------------------------------

# Step 6: Create Mahalanobis distance matrices for La and Lb
# i)E
# Example usage for La:
mahalanobis_distances_a = mahalanobis_distances(La, mean_a, covariance_a)
print("Mahalanobis distances for La:", mahalanobis_distances_a)

# You can similarly compute for Lb
mahalanobis_distances_b = mahalanobis_distances(Lb, mean_b, covariance_b)
print("Mahalanobis distances for Lb:", mahalanobis_distances_b)

# -----------------------------------------------------

# Step 7: Using model M1 to find label for new data point
# i)F.
new_data_point = [76, 32, 4.39, 1.78, 4.860753, 4.860753, 4.860753, 7.35]
mahalanobis_dist_xa = min(mahalanobis_distances(np.array([new_data_point]), mean_a, covariance_a))
mahalanobis_dist_xb = min(mahalanobis_distances(np.array([new_data_point]), mean_b, covariance_b))

if mahalanobis_dist_xa < mahalanobis_dist_xb:
    print("Label for new data point:", "xa")
else:
    print("Label for new data point:", "xb")

# ----------------------------------------------------------



import numpy as np
import pandas as pd

def find_max_euclidean_distances(dataset):
    """
    Finds two data points with the maximum Euclidean distances from each other in the dataset.

    Args:
    - dataset: pandas DataFrame containing the dataset

    Returns:
    - xa_row: Row number of the first data point
    - xb_row: Row number of the second data point
    """

    # Extract numerical features (Diagnosis)
    numerical_features = dataset.iloc[:, 1:].values

    # Find two data points with the maximum Euclidean distances
    max_distance = 0
    for i in range(len(numerical_features)):
        for j in range(i + 1, len(numerical_features)):
            distance = np.linalg.norm(numerical_features[i] - numerical_features[j])
            if distance > max_distance:
                max_distance = distance
                xa_row = i
                xb_row = j

    return xa_row, xb_row


def generate_euclidean_distances_csv(dataset, output_file):
    """
    Generates a CSV file containing all the Euclidean distances between data points in the dataset.

    Args:
    - dataset: pandas DataFrame containing the dataset
    - output_file: file path to save the CSV file
    """

    # Extract numerical features (Diagnosis)
    numerical_features = dataset.iloc[:, 1:].values

    # Generate DataFrame of all Euclidean distances
    euclidean_distances = np.zeros((len(numerical_features), len(numerical_features)))
    for i in range(len(numerical_features)):
        for j in range(i + 1, len(numerical_features)):
            distance = np.linalg.norm(numerical_features[i] - numerical_features[j])
            euclidean_distances[i, j] = distance
            euclidean_distances[j, i] = distance

    euclidean_distances_df = pd.DataFrame(euclidean_distances)
    euclidean_distances_df.to_csv(output_file, index=False)


# Example usage:
# Read the dataset
data = pd.read_csv('/content/train.csv')

# Find max Euclidean distances
xa_row, xb_row = find_max_euclidean_distances(data)
print("Row number of xa:", xa_row)
print("Row number of xb:", xb_row)

# Generate CSV file of Euclidean distances
generate_euclidean_distances_csv(data, 'euclidean_distances.csv')

import numpy as np
import pandas as pd

def find_max_euclidean_distances(dataset):
    """
    Finds two data points with the maximum Euclidean distances from each other in the dataset.

    Args:
    - dataset: pandas DataFrame containing the dataset

    Returns:
    - xa_row: Row number of the first data point
    - xb_row: Row number of the second data point
    - euclidean_distances_df: DataFrame containing all Euclidean distances
    """

    # Extract numerical features (Diagnosis)
    numerical_features = dataset.iloc[:, 1:].values

    # Find two data points with the maximum Euclidean distances
    max_distance = 0
    for i in range(len(numerical_features)):
        for j in range(i + 1, len(numerical_features)):
            distance = np.linalg.norm(numerical_features[i] - numerical_features[j])
            if distance > max_distance:
                max_distance = distance
                xa_row = i
                xb_row = j

    # Generate DataFrame of all Euclidean distances
    euclidean_distances = np.zeros((len(numerical_features), len(numerical_features)))
    for i in range(len(numerical_features)):
        for j in range(i + 1, len(numerical_features)):
            distance = np.linalg.norm(numerical_features[i] - numerical_features[j])
            euclidean_distances[i, j] = distance
            euclidean_distances[j, i] = distance

    euclidean_distances_df = pd.DataFrame(euclidean_distances)

    return xa_row, xb_row, euclidean_distances_df

# Example usage:
# Read the dataset
data = pd.read_csv('/content/train.csv')
xa_row, xb_row, euclidean_distances_df = find_max_euclidean_distances(data)
print("Row number of xa:", xa_row)
print("Row number of xb:", xb_row)
print("Euclidean distances DataFrame:\n", euclidean_distances_df)
euclidean_distances_df.to_csv('euclidean_distances.csv', index=False)